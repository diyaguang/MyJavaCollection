10.14 同步器
线程间合作顾得管理器，需要满足“共同集结点模式”。在 java.util.concurrent 包下，如果有相互合作的线程集满足这些行为模式之一，那么应该直接重用合适的类库而不要试图提供手工的锁与条件集合。

CyclicBarrier 允许线程集等待直至其中预定数目的线程到达一个公共障栅，然后可以选择执行一个处理障栅的动作。
Phaser 类似于循环 障栅，有一个可变的计数
CountDownLatch 允许线程集等待直到计数器减为0
Exchanger 允许两个线程在要交换的对象准备好时交换对象
Semaphore 允许呈现集等待直到被允许继续运行为止
SynchronousQueue 允许一个线程把对象交给另一个线程

10.14.1 信号量
一个信号量管理多个许可证，线程调用 acquire请求许可，信号量维护一个技术。许可的数目固定的，由此限制了通过的线程数量。
调用 release释放许可，许可不是必须由获取他的线程释放，染赫线程都可以释放任意数目的许可，许可的数目以至于超出初始数目。
信号量作为同步原语，可被有效的实现，有足够的能力解决常见的线程同步问题，使用信号量实现的有界队列。

14.10.2 倒计时门栓
让一个线程集等待直到计数变为0。倒计时门栓时一次性的，一旦计数为0，就不能重复用了.调用countDown，所有工作器线程就可以继续运行了。
用线程数初始化门栓，每个工作器线程在结束前将门栓计数减1.另一个获取工作结果的线程在门外等待，一旦所有工作器线程终止该线程继续运行。

14.10.3 障栅
线程到达集结点后，等待其他所有线程到达集结点。
CyclicBarrier类实现了一个集结点，称为 障栅（barrier）。当所有部分都准备好时，需要把结果组合在一起。当一个线程完成了他的那部分任务后，我们让他运行到 障栅处，一旦所有的线程都到达了这个障栅，障栅就撤销，线程就可以继续运行。

CyclicBarrier barrier = new CyclicBarrier(nthreads);   创建障栅，给出线程数。
public void run(){
	doWork();
	barrier.await();
}
每个线程完成一些工作，完成后在障栅上调用 await，这个方法可以有一个可选的超时参数。barrier.await(100,TimeUnit.MILLISECONDS);

如果一个在障栅上等待的线程离开了障栅，那么障栅就被破坏了。所有其他线程的 await方法抛出了 BrokenBarrierException异常，那些已经在等待的线程立即终止 await的调用。
可以提供一个可选的 障栅动作（barrier action），当所有线程到达障栅的时候，就会执行这个动作。
Runnable barrierAction = ....;
CyclicBarrier barrier = new CyclicBarrier(nthreads,barrierAction);   //配置障栅到达后的后续动作
障栅被称为是循环的，所有等待线程被释放后被重用。有别于 CountDownLatch（只使用一次）

14.10.4 交换器
当两个线程在同一个数据缓冲区的两个实例上工作的时候，就可以使用交换器（Exchanger）。

14.10.5 同步队列
同步队列时一种将 生产者和消费者线程配对的机制。当一个线程调用 SynchronousQueue 的 put 方法是，会阻塞直到另一个线程调用 take方法为止。
数据仅仅沿一个方法传递，从生产者到消费者。
即使 SynchronousQueue类实现了 BlockingQueue接口，它没有包含任何元素，他的 size方法总是返回0.


14.11 线程与 Swing （略）


