14.4.2 守护线程
使用 t.setDaemon(true) 调用线程对象的 setDaemon(true)方法
作用：为其他线程提供服务，当只有守护线程时，虚拟机就退出了
标识为守护线程的调用，必须在线程启动之前调用

14.4.3 未捕获异常
线程的 run方法不能抛出受查异常，非受查异常会让线程终止，线程死亡，在线程死亡之前，异常被传递到一个用户未捕获异常的处理器。
处理器实现 Thread.UncaugheExceptionHandler接口类，这个类只有 void uncaugheExeption(Thread t,Throuable e) 方法。
使用 setUncaughtExceptionHandler 为线程安装一个处理器，setDefaultUncaughtExceptionHandler 安装默认的处理器
在处理其中可使用日志 API等方式发送未捕获的异常，默认的线程处理器为空。

14.5 同步
两个以上线程对共享的同一数据进行存取，这样被称为 竞争条件

14.5.1 竞争条件的例子
避免多线程引起的共享数据的竞争，需要使用“同步存取”。

14.5.2 竞争条件详解
当两个线程试图同时更新同一个账户的时候，这个问题就出现了。真正的问题是线程操作的方法执行过程中可能被中断，如果能够给确保线程在失去控制之前方法运行完成，那么将不会出现这个错误。

14.5.3 锁对象
两种方式，1. synchronized关键字提供一个锁以及相关的“条件”
2. 使用 ReentrantLock锁对象
myLock.lock();
try{
	critical section
}finally{
	myLock.unlock();
}
这个结构确保任何时刻是能有一个线程进入临界区，一单一个线程封锁了锁对象，其他任何线程都无法通过 lock语句，当其他线程调用lock时，他们被堵塞，知道第一个线程释放锁对象。

如果使用锁，不能使用带资源的 try语句，他的首部希望声明一个新变量，但是如果使用一个锁，则需要使用多个线程共享的那个变量，而不是新变量。
每个对象都有自己的ReentrantLock对象，不同的线程访问不同的对象，则不会发生阻塞。

锁是“可重入”的，线程可以重复的获得已经持有的锁。锁保持一个持有计数来跟踪对 lock方法的嵌套调用。线程在每次调用 lock 都要调用 unlock 来释放锁，被一个锁保护的代码可以调用另一个使用相同的锁的方法。
通常只有锁对象的持有计数为0时，线程释放锁。
可能要保护需若干个操作来更新或检查共享对象的代码，确保这些操作完成后，另一个线程才能使用相同对象。

ReentrantLock(boolean fair)：带有公平策略的公平锁，偏爱等待时间最长的线程。但是性能大大降低，默认锁没有被强制公平的。

14.5.4 条件对象
当线程进入了临界区，却发现在某一条件满足之后才能执行，要使用一个条件对象来管理那些已经获得了一个锁，但是却不鞥做有用工作的线程。条件对象经常被称为条件变量。
例如 if(bank.getBalance(from)>=amount) bank.transfer(from,to,amount) 这个语句的执行，很有可能在 执行完if语句后就被中断，在线程再次执行前，账户余额可能已经低于提款金额，必须确保没有其他线程在本次检查余额与账户活动之间修改余额，通过使用锁来保护检查与转账动作来做到这一点。
一般将检查条件放入到锁块中。但是要看怎么处理。线程被锁住后，其他线程没有操作的机会，如果这个判断条件的相关内容也是在这个操作中，则这个条件将无法达到，这就是为什么需要条件对象的原因。

一个锁对象可以有一个或多个相关的条件对象，可用 newCondition方法获得一个条件对象。习惯上给一个条件对象命名为可以反映他说表达的条件对象。
class Bank{
	private Condition sufficientFunds;
	public Bank(){
		...
		sufficientFunds = bankLock.newCondition();
	}
}
在操作时，如果发现条件不满足，则调用 sufficientFunds.await(); 调用这个操作后，线程被阻塞了，并放弃了锁。
等待获得锁的线程和调用 await方法的线程存在本质上的不同。
线程调用 await方法，它进入该条件的等待集。当锁可用时，该线程不能马上解除阻塞。还是处于阻塞状态，直到另一个线程调用同一条件上的 signalAll方法时为止。也就是说另一个线程需要调用 signalAll方法。sufficientFunds.signalAll(); 这个调用重新激活因为这一条件而等待的所有线程。线程从等待集当中移出时，调度器再次激活他们。
通常，对 await方法的调用，应该在如下形式的循环体中：
while(!(ok to proceed))
	condition.await();