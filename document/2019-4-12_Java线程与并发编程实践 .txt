第七章 锁框架
locks 提供了包含多种接口和类的框架，针对条件进行加锁和等待。
同步及低级别的锁：
方法或代码块上标记 synchronized关键字，JVM通过指令 monitors，monitorenter，monitorexit 来支持操作。
每个Java对象都和一个监听器关联，监听器是互斥的构造，阻止多条线程同时在临界区中进行并发操作。在线程可以进入临界区之前，需要锁住监听器。否则一直会阻塞。
处理原理：锁住一个监听器，存在主存中的共享变量的值会被读取到对应的拷贝中，然后存储在线程的工作内存中，离开临界区，线程会释放监听器，共享变量的值会写回主存。这个动作能保证线程使用这些变量最近的值并且不会污染这些值。这个操作称为可见性。 volatile关键字仅仅解决可见性

7.1 锁
使用接口 Lock提供比监听器更加有弹性的锁操作。
lock：获取锁
lockInterruptibly：除非调用线程被中断，否则获取锁，锁不可用会一直等待。
newCondition：返回一个新的绑定到当前锁实例上的 Condition实例
tryLock：试图获取锁，返回 true或false，有超时版本
unlock：释放锁
获得的锁必须释放，同步块是隐式的同步锁操作。同步方法和代码块，隐式的监听锁关联每个对象。当火哥锁被获取，会以相反的顺序释放。
接口 Lock的实现允许使用在不同的作用域中获取、释放锁这样的技术，同时以不同的顺序允许多个锁被获取和释放。块状锁的缺失溢出了发生在同步方法和代码块上的自动释放锁的功能。

7.2 重入锁
重入的意思：获取锁的操作的粒度是 “线程”，而不是调用。重入的实现方式是为每个锁关联一个获取计数值和一个所有者线程，当计数为零时，任务没有被任何线程所持有。
当线程请求一个未被持有的锁时，JVM记入持有者，并将获取计数值置为1，如果同一个线程再次获取这个锁，计数值递增，而线程代码推出代码块时，计数器递减，当计数值为零时，这个锁将被释放。
重入意味着线程可进入它已经拥有的同步代码块。
有个持有量计数
使用 ReentrantLock 实现这个冲入锁，实现了 Lock借口，这个锁和一个持有量相关联。当持有量降为0，锁就会被释放掉。具有更好的性能。
构造函数：ReentrantLick(),有个可选的 boolean fair 参数，是否创建一个公平策略的锁。
常用方法：
lock：锁对象
unlock：释放锁对象
isFair：返回是否公平策略
isHeldByCurrentThread：在锁被当前线程持有的情况下，返回 true


7.3 条件

7.4 读写锁

7.5 重入读写锁