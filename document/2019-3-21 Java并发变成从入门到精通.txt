3.8 什么是死锁
当两端代码都在等待对方释放锁才能继续往下的工作时，产生死锁。
方法嵌套调用上不能产生死锁的调用。

3.9 Java 关键字 volatile 修饰变量
说明：有关内存模型的说明

内存模型：计算机的内存模型，数据放入到主存中，操作主存，效率较低。因而产生了 CPU高速缓存。运行时将数据复制到高速缓存中，运算结束后，再将高速缓存数据放入到主存中。
多线程，多核CPU中，每个线程都有自己的高速缓存，因而会产生“缓存一致性”问题。这种被多个线程访问的变量为 共享变量。
解决方法：
1.通过在总线上增加 LOCK# 锁：CPU通信都是通过总线进行的，增加总线锁，阻塞其他CPU对其内部组件访问，但是效率低下。
2.通过缓存一致性协议：其中有名的是 Intel 的 MESI协议，保证每个缓存中使用的共享变量的副本是一致的。

编程中的三个重要概念：
1.原子性：一个操作或多个操作，要么全部执行，在执行过程中不会被任何因素打断，要么都不执行。
2.可见性：当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。
3.有序性：程序执行顺序按照代码的先后顺序执行。在正常的 CPU执行顺序上，会发生“指令重排”（Instruction Reorder）（处理器为提高运行效率，对代码进行优化，不保证语句执行先后顺序与代码顺序相同，但是会保证程序最终执行结果和代码顺序的执行结果一致。重拍顺序时，会考虑数据的依赖性，这种优化不会影响单线程的执行结果。但是会影响到多线程并发执行的正确性。）并发程序要想正确执行，必须保证，原子性，可见性，有序性。这三点必须保证，否则就会不正确。

Java内存模型：JMM
屏蔽各个硬件平台和操作系统的内存访问差异，定义了程序中变量的访问规则（没有限制引擎使用寄存器或高速缓存，也没有限制编译器对指令进行重排序），会存在 一执行问题和指令重排序的问题。
所有的变量都存在主存中，每个线程都有一个工作内存。线程对变量的操作都要在工作内存中操作，不能直接对主存操作，线程之间不能访问其他线程的工作线程的工作内存。
Java中的原子性：对基本数据类型的变量的读取和赋值操作是原子性的。但是多个原子操作放在一起就不是原子的了。只有简单的读取、赋值才是原子操作。变量与变量之间的赋值都不是。在32位平台下，对64位数据读取和操作是通过两个操作来完成的，所以也不是原子操作。在新的 JDK中，好像保证了64位的原子性操作。多操作的集合只能通过 synchronized 和 lock 来保证。
Java中的可见性：通过 volatile关键字来保证可见性。使用 volatile修饰的共享变量都会直接操作主存，不是用这个关键字的只能通过 synchronized 和 lock 来保证。
Java中的有序性：同样会影响多线程的操作，通过 volatile关键字保证一定的“有序性”，或通过 synchronized 和 lock 来保证。
JMM具有一些先天的“有序性”，称为 happens-before（现行发生原则）：

程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作
锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作
olatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作
传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C
线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作
线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生
线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行
对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始

解析 volatile关键字：
使用该关键字具有两个含义：1.保证不同线程对变量进行操作时的可见性。2.禁止进行指令重排序。
“观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令”
synchronized关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而volatile关键字在某些情况下性能要优于synchronized，但是要注意volatile关键字是无法替代synchronized关键字的，因为volatile关键字无法保证操作的原子性。可以被写入 volatile 变量的这些有效值独立于任何程序的状态，包括变量的当前状态。需要保证操作是原子性操作，才能保证使用volatile关键字的程序在并发时能够正确执行。
