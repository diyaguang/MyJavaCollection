第一部分 线程并发基础

第一章，概念部分

1.1 CPU核心数，线程数

32位，64位，指CPU位宽，支持更大范围的数据运算，支持更大容量的内存
多核心：单芯片，多处理器，并行处理
多线程：复制处理器上的结构状态，同一处理器多个线程，同步执行并共享处理器的执行资源
核心数，线程数：增加 核心，增加线程数，Intel 超线程技术后，核心与线程数为 1:2

Linux查 CPU信息：
cat /proc/cpuinfo | grep name | cat -f2 -d: | uniq-c
grep 'processor' /proc/cpuinfo | sort -u | wc -l
grep 'core id' /proc/cpuinfo | sort -u | wc -l

1.2 CUP时间片轮转机制
轮转调度（时间片）允许运行的时间。
调度程序：维护一张就绪进程列表
CPU对进程切换是有时间开销的，时间片太短，将导致过多进程切换，降低CPU效率。太长，可引起对短的交互请求的响应变差，一般时间片被设置为 100ms 比较合理。

1.3 什么是进程，什么是线程
进程是程序运行资源分配的最小单位。同一个进程中的多个线程共享该进程的所有资源，进程与进程之间是相互独立的。进程是一个独立单位。进程是程序在计算机上的一次执行活动。
线程是CPU调度的最小单位，必须依赖进程而存在。线程是进程的一个实体，CPU调度，分派的基本单位，独立运行的基本单位。线程无处不在。

1.4 进程与线程对比
进程只是线程的容器，对资源是拥有的，具有独立的内存地址空间，仅仅是资源分配的基本单位，进程间独立。
线程是执行的最小调度单位，活泼，在进程的地址空间执行代码，不拥有资源，但占用CPU，独立调度，共享进程的资源，可以相互通信，影响。

1.5 什么是 并行运行
程序同时所开启的运行中的线程数 <= CPU数量*CPU的核心 (CPU数量*CPU的线程数)

1.6 什么是 并发运行
必须有的单位时间，程序同时所开启的运行中的线程数 > CPU数量*CPU的核心 (CPU数量*CPU的线程数)
通用的并发量算法，1S内，2CPU，8核，16线程
1000ms*16*2/10ms+10ms =1600 个并发，如果为 3S，则并发量是 4800个，理想状态

1.7 什么是 吞吐量
单位时间内，成功传送数据的数量
网络吞吐量：某个时刻，两个节点之间，提供给网络应用的剩余带宽，设备能够接受的最大速率。
系统吞吐量：每个时间段所处理的进程数来度量
带宽与吞吐量的区别：单位都是 Mbit/s ，带宽是表示一段链路上每秒能传送的比特数，可用带宽。吞吐量是实际链路中每秒能传送的比特数。因为有各种防护墙算法和折损，所以吞吐量更表示实际传送的数量。
系统吞吐量：系统在单位时间内所处理的信息量，每小时或每天所处理的进程数来度量。

1.8 高并发编程的意义以及其好处和注意事项
案例：在高性能 Web调优的项目，将静态资源地址用两三个域名去加载，每多一个子域名，浏览器在加载页面时候就会多开几个线程去加载页面资源，提升网站的响应速度。
要注意的问题：线程之间的安全性。线程之间的死循环过程。线程太多会将服务器资源耗尽形成死机

1.9 分布式计算、并行运算、并发运算
分布式计算：将需要巨大计算能力的问题，分解成许多小的部分，然后分配给许多计算机处理。计算结果综合起来得到最终结果。

1.10 Linux 与 Windows 对于并发采用不同的机制


第二章 认识 Java 里面的 Thread

2.1 线程简单实现的三种方法

2.2 Thread里面的属性和方法

2.3 关于线程的中断机制
Java没有提供任何机制来安全的终止线程
第一种方式：Thread.stop() ，会抛出 ThreadDeath对象作为异常。停止一个尚未启动的线程，稍后启动该线程，则立即终止。如果异常不活了 ThreadDeath对象，则必须重新抛出该对象，这样线程才会真正终止。

第二种方式：利用 Thread.interrupt() 方法和机制
中断是一种协作，或者说告诉某一线程，被中断了，并不能直接直接终止该线程。被中断的线程自己来处理中断，执行相应的操作。在线程中，使用一个 boolean类型来标识是否有中断请求。被中断的线程可以在合适的时候处理中断请求，或不处理。
static boolean interrupted() 测试当前线程是否已经中断，并且会改变中断状态（清除状态）
isInterrupted() 判断是否中断，不会改变中断状态
interrupted() 中断线程，只有这个方法会设置中断状态为 true

可在主线程中指定其他线程的中断状态，使用 Thread.currentThread().isInterrupted() 来进行判断。
原理：Java在处理中，若该线程处在可中断的状态下，那么线程会被立刻唤醒，同时会收到 InterruptedException异常，同时若阻塞在IO上，对应资源会被关闭，若不执行 interrupted()方法，则线程处理的任何IO资源时，都会关闭这些资源，除了执行 interrupted()。
也就是说 不适用 isInterrupted来判断当前线程的状态，可使用 try...catch 来获取 InterruptedException 异常来处理是否线程被中断，然后进行不同的处理。
注：线程终止前，一定要对 isInterrupted 的状态进行处理，否则线程在死循环的情况下，线程永远不会结束。

2.4 线程的生命周期
5种状态：new，runnable，running，blocked，dead
新建后，为 new 状态，未启动，只是创建了一个实例，是 not alive 的。
启动后，等待被分配时间片，为 runnable 状态，就绪队列，是 alive的。
获得CPU后，为 running的，正在执行 run() 方法，是 alive的。
由于某些原因，导致线程让出 CPU 并暂停自己的执行，则进入 堵塞状态，blocked。（如 sleep()，wait() 后使用 notity() 可进入就绪状态。Suspend() 后用 resume() 方法来恢复，为阻塞的状态也是 alive 的。）
当线程执行完毕后，或被杀死后，就进入死亡状态，为 dead，是 not alive的。分为自然终止，异常终止（如调用 stop() 后）。

2.5 什么是守护线程
 
2.6 线程组

2.7 当前线程副本 ThreadLocal

2.8 线程异常的处理

