8.4 Nginx线程池 （看不懂啊 o(╥﹏╥)o）
不做IO，不分占CPU和内存，只做负载分发。在 Nginx中没有给定线程池的相关概念和配置。通过其他的配置来达到优化的目的。
1.ngx_http_limit_req_module 模块 
通过定义的键值来限制请求处理的频率，可以限制来自单个IP地址的请求处理频率。通过一种“漏桶”的方式，固定每秒处理的请求数，推迟过多的处理。
设置对应的共享内存限制域和允许被处理的最大请求数阈值。超过处理频率的请求会被延迟，当延迟的请求数超过了定义的阈值，将返回503，阈值默认为0.
2.ngx_http_limit_conn_module 模块
限定每个键值的连接数，可以设定单一IP来源的连接数。指定一块已经设定的共享内存空间，以及每个给定键值的最大连接数。当连接数超过最大连接数时，服务器返回 503.

8.5 数据库连接池
连接过程：使用 DriverManager检查并注册驱动程序 -> Driver就是注册了的驱动程序，会调用其中的connect方法 -> connect根据connUrl创建一个 Socket连接 -> Socket连接将被用来查询指定的数据库，并最终返回一个结果。
昂贵：每次连接都创建一个 Socket连接，所花费的时间比查询本身要大很多。
基本原理：数据库连接建立一个“缓冲池”，在缓冲池中放入一定数量的连接。可以通过连接池管理、监视连接的数量，使用情况，状态，为优化和性能测试提供依据。
主要由：连接池创建+连接池中连接的使用管理+连接池的关闭 三部分组成。
Java中的很多容器可以方便的构建连接池（Vector，Stack等）。
连接池策略：使用最大连接数来控制当前所开的连接数。如果达到则按最大等待时间进行等待，如果超出时间，则抛异常。客户使用完连接后释放，先判断该连接引用次数是否超过了规定值，如果超过就从池中删除该连接。
当应用退出时，关闭连接池中所有的连接，释放连接池相关的资源。
推荐使用 Alibaba 的 Druid 连接池。

8.6 如何在分布式系统中实现高并发
实现高并发的前提条件：了解物理机器，了解业务，了解程序。
业务拆分是核心，拆分角度：任务性质，并发数量，执行时间，优先级，依赖性，资源性质，业务耦合度。
业务和任务分析后，可以合理的配置线程池，从而实现高可用，高并发：
1.任务性质不同的任务，可以用不同规模的线程池分开处理。
2.优先级不同的任务可以使用优先级队列 PriorityBlockingQueue来处理
3.执行时间不同的任务可以交给不同规模的线程池来处理，或者也可以使用优先级队列，让执行时间短的任务优先执行
4.依赖数据库连接池的任务，线程数应该设置越大
5.建议使用有界队列，有界队列能增加系统的稳定性和预警能力，可以根据需要设大一点。

对服务的内容分析后，应该及时进行部署分离，实现高性能的分布式，原则：
1.渠道分离（无线客户端，PC端，API接口等）
2.运营商分离（电信，联通等）
3.服务内容划分（文字，图片，视频，下载等）
4.按照访问密集型划分（高并发和地并发的可以分开部署在不同的环境下）
5.按照不同业务线进行划分（前台项目，BBS，后台管理项目等）


第九章 线程的监控及其日常工作中如何分析

9.1 Java 线程池的监控
如果需要监控线程池，则需要自定义线程池，继承 ThreadPoolExecutor，实现 beforeExecute（任务执行前），afterExecute（任务执行后），termainated（线程池关闭前） 来做一些事情。

beforeExecute(Thread t,Runnable r)：每执行一个工作任务线程前都会执行此实现的方法。
t：放在线程池里面要执行的线程，r：将要执行这个线程的线程池里面的工作线程。
afterExecute(Runnable r,Throwable t) ：每执行一个工作任务线程之后都会执行的方法
r：已经运行结束的工作线程，t：运行异常
terminated()：线程池关闭之前可以干一些事情

线程池中常用监控线程的方法：taskCount，completedTaskCount，largestPoolSize，getPoolSize，getActiveCount

9.2 ForkJoin 如何监控
提供了一些可以查询其状态的信息的方法：
getPoolSize：内部线程池 worker线程们的数量
getParalleLism：并行的级别
getActiveThreadCount：返回当前执行任务的线程的数量
getRunningThreadCount：返回没有被任何同步机制阻塞的正在工作的线程
getQueuedSubmissionCount：返回已经提交给池，还没有开始执行的任务数
getAueuedTaskCount：返回已经提交给池，已经开始执行的任务数
hasQueuedSubmissions：这个池是否有 queued任务还没有开始执行
getStealCount：worker线程已经从另一个线程偷取到的时间数
isTerminated：fork/join 池是否已经执行完成
例代码（略）

9.3 Java内存结构
分为：程序计数器，JVM栈，本地方法栈，共享堆，方法区
1.程序计数器：较小的一块内存，当前线程所执行的字节码的行号指示器，根据这个值来选取吓一条需要执行的字节码指令。每个线程都有一个独立的程序计数器。是线程私有的内存。没有规定内存溢出的内存区域。
2.JVM栈：线程私有的，与线程的生命周期相同。Java方法执行的内存模型，每个方法执行都会创建一个栈帧用于存放局部变量表，操作数栈，动态连接，方法出口等信息。对应一个栈帧从入栈到出栈的过程。存放8种基本类型，对应引用，方法返回地址returnAddress。局部变量所需的内存空间在编译期间完成分配。
3.本地方法栈：是为虚拟机调用的操作系统本地方法服务。
4.共享堆：Java虚拟机管理的内存区域最大一块，被所有线程所共享。在虚拟机启动时创建。堆内存就是存放对象实例的。GC回收的主要区域。
5.方法区：被各个线程共享的内存区域，存储被虚拟机加载的类信息，常亮，静态变量，编译后的代码数据。也称为 Non-Heap（非堆）

JVM的垃圾回收机制：
垃圾回收算法将 JVM中，堆和非堆空间划分为三代。年轻代和老年代就是说的 共享堆，垃圾回收主要针对这两个代。
年轻代：动态的存储，存储新产生的对象
老年代：存储年龄大一些的对象
永久代：就是 方法区，基本不参与垃圾回收
年轻代又分为 eden + survivor + survivor 三个区域（eden伊甸园，survivor幸存者）。刚开始创建的队形都放在 eden区域。生命周期短的对象尽量留在年轻代。当eden区申请不到空间的时候，进行 minorGC，把存活下来的对象拷贝到 survior区域。
年老代主要存放声明周期比较长的对象，比如缓存对象。

JVM内存垃圾回收过程：
 1.对象在Eden区域完成内存分配过程
 2.当 eden区满了会触发 minorGC，进行（eden+1survivor）区的垃圾回收。
 3.eden区不能被回收的对象，放到空的 survivor中，另一个survivor里不能被GC回收的对象也会被放入这个 survivor中。eden肯定会被清空，始终保证一个 survivor是空的。
 4.如果 survivor满了，对象被 copy到 old区，或对象足够old，则也被放入 Old区
 5.当 Old区被放满后，进行 fullGC

 MinorGC：年轻代所进行的垃圾回收，非常频繁，速度也比较快
 MajorGC：老年代的垃圾回收，发生一次 MajorGC至少伴随一次 MinorGC，速度较慢
 FullGC：整个堆内存进行垃圾回收，很多时候是 MajorGC
 说明：MagorGC和 FullGC 最耗CPU，影响程序响应，根据响应原则合理设置年轻代和老年代的大小。一旦 FullGC频繁发生的时候，基本上就快要内存溢出了。

 JVM内存垃圾回收过程中对象分配的原则
 1.对象优先分配在 eden区，没有足够空间时，执行一次 minorGC
 2.大对象直接进入老年代（指需要大量连续内存空间的对象），避免在 eden区和两个Survivor区之间发生大量的内存拷贝
 3.长期存活的对象进入老年代，每个对象定义了一个年龄计数器，经过你一次MinorGC，对象进入 Survivor区，每经历一次 MinorGC，对象年龄+1，直到达到阈值对象进入老年区。
 4.动态判断对象的年龄，当 Survivor区中相同年龄的所有对象大小的总和大于 Survivor空间的一半，则年龄大于等于该年龄的对象直接进入老年代。
 5.空间分配担保：每次进行 MinorGC，JVM会计算 Survivor区移至老年区对象的平均大小。如果大于老年区剩余的大小，则进行一次 FullGC，如果小于，则看 HandlePromotionFailure设置，如果true，则只进行 MinorGC，如果false，则进行 FullGC

 JVM内存垃圾回收的机制有三种
 串行收集器：使用单线程处理所有垃圾回收工作，无需多线程交互，效率较高
 并行收集器：对年轻代进行并行垃圾回收
 并发收集器：保证大部分工作都并发进行，适合对响应时间要求比较高的中，大规模应用。

 常见的内存溢出的三种情况（略）


9.4 可视化监控工具的使用

9.4.1 VisualVM的使用
是JDK的一个集成的分析工具，监控应用程序的性能和内存占用情况，监控应用程序的线程，进行线程转储，或堆转储，跟踪内存泄漏，监控垃圾回收器，执行内存和CPU分析，保存快照以便脱机分析应用程序。JDK1.4以上的版本的程序都能被监控。
在 $JAVA_HOME/bin 目录下，是 jvisualvm.exe

9.4.2 JConsole的使用
内置的 Java性能分析器，从命令上或 GUI shell 上运行，监控 Java应用程序性能和跟踪Java中的代码。在 %JAVA_HOME%\bin\jconsole.exe 位置

9.4.3 OracleJava Mission  Control
JDK下默认提供的一个非常好的监控和分析工具，在 %JAVA_HOME%\bin\jmc.exe 位置

9.5 Linux 线程分析监控使用方式（略）

9.6 Linux 分析监控的运行脚本（略）

9.7 Eclipse 里如何调试并发程序 (略)

9.8 如何通过压力测试来测试服务器的抗压能力（略）

9.9 MultithreadedTC 测试并发介绍（略）

第十章 Android中线程的应用 （略）



